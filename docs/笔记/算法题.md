2.算法，给2个字母的字符串，找出2个字符串最长的公共子串

求一棵树两个节点的最近的公共父节点


6. 写一个题，找一个无序数组的中位数

   https://www.cnblogs.com/shizhh/p/5746151.html

   容易想的思路：排序，求中间值

   比较容易写的思路：

   首先将数组的前（n+1）／2个元素建立一个最小堆。（PriorityQueue）

   然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，接着看下一个元素。如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。重复这个步骤，直到数组为空。

   当数组都遍历完了，那么，如果数组长度为奇数，堆顶的元素即是中位数。如果是偶数，则堆顶的前两个元素的平均值即中位数。

   可以看出，长度为（n＋1）／2的最小堆是解决方案的精华之处。如果

7. 写了个快排，然后让我找到无序数组第k大的一个数，我说先排序再找，实际上可以用快排的partition函数。

   ->可以用容量为K的最小堆实现，原理同第六题

8. 快排的时间复杂度，最坏情况呢，最好情况呢，堆排序的时间复杂度呢，建堆的复杂度是多少。

   快排：在最糟糕得情况下时间复杂度是O(n²)，平均的复杂度是O(nlogn)

   

   堆排序：初始化堆（建堆）的复杂度为O(n)。调整堆的复杂度为O(n*log n)。所以，总体复杂度为O(n*log n)

   https://www.cnblogs.com/lylhome/p/13276081.html


第一题：写一个层序遍历  ---BFS。

https://www.runoob.com/data-structures/binary-search-level-traverse.html

**通过引入一个队列来支撑层序遍历：**

- 如果根节点为空，无可遍历；
- 如果根节点不为空：
  - 先将根节点入队；
  - 只要队列不为空：
    - 出队队首节点，并遍历；
    - 如果队首节点有左孩子，将左孩子入队；
    - 如果队首节点有右孩子，将右孩子入队；

第二题：写一个插入树节点到一颗排序树的插入方法，使用递归方式找到插入位置即可。

递归和非递归方式https://blog.csdn.net/qq_35181209/article/details/52798166



第三题：一个有向图用邻接矩阵表示，并且是有权图，现在问怎么判断图中有没有环。
我说直接dfs走到原点即为有环，刚开始写的时候我又问了一嘴是不是只要找到一个就行，面试官说是的，然后我说这样应该用bfs，有一次访问到原节点就是有环了。
面试官问我不用递归能不能做这个题，其实我都还没开始写。然后我就说没有思路，他提示我拓扑图。我没明白拓扑图能带来什么好处。现在一想，好像当访问过程中找不到下一个节点时就说明有环。做一个访问标记应该就可以。
第四题：一个二叉树，找到二叉树中最长的一条路径。
我先用求树高的方式求出了根节点的左右子树高度，加起来便是。
然后面试官提示需要考虑某个子树深度特别大的情况，于是我用遍历的方式刷新最大值，用上面那个方法遍历完整个树即可
堆中数据获取最小的K个数.（算法类问题）


. 链表反转

4. 区间合并 [1,3]  [2,4] [7,10]

   https://leetcode-cn.com/problems/merge-intervals/


5. 整数开根号，保留m位

   http://bigdatadecode.club/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E4%B9%8Bn%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%E4%BF%9D%E7%95%99m%E4%BD%8D%E5%B0%8F%E6%95%B0.html
