####  41.秒杀场景一般有什么特点？设计秒杀场景需要重点考虑哪些点？

思考顺序如下，客户端→代理层→应用层→数据库→压力测试：

https://segmentfault.com/a/1190000021051028?utm_source=tag-newest

- 客户端 90% 静态 HTML+10% 动态 JS；配合 CDN 做好缓存工作。

- 做好数据的预估，隔离，合并。

- 上线之前记得进行压力测试。

- 校验：前端做好校验（比如用户必须登录、秒杀开始前按钮不可用，秒杀链接不可见，**URL动态化**）

- 防脚本：对同一IP、UID等进行限流，防止自动抢购脚本

- 限流：对整体流量进行限流（漏桶、令牌桶），只允许少部分流量进入服务后端秒杀程序。

- 削峰：实现削峰的常用的方法有前端添加一定难度的验证码后端利用缓存和消息中间件等技术。发送秒杀到的MQ消息给相应的业务端进行处理，并给用户端返回排队中，如果客户端收到排队中的消息，则自动进行轮询查询，直到返回秒杀成功或者秒杀失败为止

- 自动扩缩容：分布式集群，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。

- 缓存减轻DB压力：将库存数据存入redis缓存，服务器缓存秒杀商品，直接调用缓存层，无需穿透到数据库层找数据。

- 防止超卖：分布式锁实现redis+mysql数据库数据的一致性

- 秒杀结束标识

- 防止重复秒杀

- 预扣库存：下单后扣库存，保留十分钟，在十分钟内未付款就不保留。如果付款时发现库存不足则不允许付款。

- 超时自动取消：

  https://blog.csdn.net/zzl429556205/article/details/103833319

  （1）Redis缓存

  Redis的zset是一个有序集合，每一个元素都关联了一个score，通过score排序来获取集合中的值。

  实现：将订单超时时间戳与订单号分别设置为score和member，系统扫描第一个元素判断是否超时。

  （2）使用消息队列

  RocketMQ延时消息（只支持特定级别的延迟消息，1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h）

  RabbitMQ有延时对列
  
- **设计Plan B兜底方案**

  再牛逼的系统也会问题，比如超大流量导致宕机，出现最坏情况，所以需要设计Plan对应高可用性。

  服务降级、隔离、熔断等

![img](images/miaosha.png)