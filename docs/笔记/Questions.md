### 1.自我介绍

###  2.算法，给2个字母的字符串，找出2个字符串最长的公共子串



###    5.线程安全是什么？为什么发生线程不安全？如何解决？sysnchiorized 和reentranslock的区别是什么？

###    6.什么是内存泄露和内存溢出？各自会引发什么问题？

**内存溢出 out of memory**，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory，那就是内存溢出。

**内存泄露 memory leak**，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

###    7.hashmap的内部实现是怎样的？扩容机制是什么？1.7和1.8的实现有哪些具体不同区别，以及他们的底层结构有哪些变更？



###    9.aqs有了解吗？内部的具体实现机制是什么？reentranslock的公平与非公平锁的实现机制有哪些？

volatile的state字段，来保存当前锁的状态。使用CAS的方式修改state字段保证锁状态的转换。

公平锁：线程申请锁时候，发现有锁，则加入等待队列队尾。

非公平锁：线程申请锁时候，先抢占资源，如果抢不到，加入等待队列，优点是可以减少唤起线程的开销。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

   10. ### CountDownLatch 和 CyclicBarrier 主要区别是什么？

   CountDownLatch是门闩的意思，可以实现控制N个线程全部运行完之后，才进行接下来的操作，只能用一次。

   CyclicBarrier ，实现控制N个线程到达某一状态后，继续运行下面流程，可以复用多次。

   

###   12.jvm1.8的内存模型什么样子的？相比之前有哪些变更？方法区和堆区主要区别是什么？

   ![JVM8内存图](JVM03-03-5.png)

   方法区的实现由1.7的永久代变为了元空间。

   运行时常量池（Runtime Constant Pool）1.7到了堆内存中；1.8之后出现了元空间，它又回到了方法区。

   方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。

```
堆是JVM中所有线程共享的，分配对象的区域。
```

####    13.jvm常见的垃圾回收器和垃圾回收算法有哪些？

   常用组合：

   Serial New ->Searal Old

   Parallel Scavenge->Paraller Old

   ParNew->CMS

   G1

   回收算法：

   标记清除->年轻代  、 CMS

   标记整理->老年代

   复制 ->年轻代

####    14，了解g1吗？

   Region

   CardTable

   RSet

   ygc   mixedgc  fullgc->Serial-old

   逻辑分代，物理不分代

   可预测停顿时间，尽可能达到

   步骤：

​	初始标记

   并发标记

   最终标记

​	筛选回收

#### 15.jvm的整个类的加载执行过程的具体步骤有哪些？

   加载 ： class文件

   链接  ：1.校验  ：文件格式，语法。2.准备 ：静态变量赋默认值  3.解析：将常量池种的符号引用解析为直接引用

   初始化： 静态变量初始化 

####    16.jvm双亲委派模型是什么？具体是怎么实现的？它的主要作用是什么？如何去破坏双清委派模型？

   类加载的时候，从子到父加载器的缓存中逐级查找，如果找不到，则从父到子逐级委托加载器去加载

   作用：安全性考虑，防止Java的类文件被篡改，比如你自己自定义个java.util.String

   打破：实现自定义ClassLoader，重新loadClass方法。

   自定义ClassLoader：继承ClassLoader，重写findClass方法。使用defineClass方法进行类的定义











####  35.mysql如何做到线上读写分离？如何处理读写分离的？

通过binlog实现主从复制，可一主多从，双主互备，写主读从







####  41.秒杀场景一般有什么特点？设计秒杀场景需要重点考虑哪些点？

思考顺序如下，客户端→代理层→应用层→数据库→压力测试：



- 客户端 90% 静态 HTML+10% 动态 JS；配合 CDN 做好缓存工作。
- 接入层专注于过滤和限流。
- 应用层利用缓存+队列+分布式处理好订单。
- 做好数据的预估，隔离，合并。
- 上线之前记得进行压力测试。

![img](https://static001.infoq.cn/resource/image/a8/a4/a815d3cd04f6f07e225c6824ee52e6a4.png)

####  42.在秒杀场景中对于超时订单如何能做到取消？

https://blog.csdn.net/zzl429556205/article/details/103833319

####  43.秒杀中如何防止超卖？减库存和支付如何保证数据一致性？如何尽量提升秒杀的效率？

https://www.zhihu.com/question/54895548 如何设计秒杀系统？

https://www.infoq.cn/article/ypqschsrdsk8bv5nhny4

####  44.线上优化一些项目的请求慢的接口？用什么方式去优化？分别从哪几个维度去考虑？如何保证自己的优化方向正确并有效，有哪些注意的点？

https://tech.meituan.com/2016/12/02/performance-tunning.html  美团

https://blog.csdn.net/lilizhou2008/article/details/106935052

1、针对 HTTP 请求的优化，是否能升级 HTTP 1.1 到 HTTP2 ？

2、针对带宽瓶颈的升级？

3、是否做了 DNS 缓存？

4、可以通过 LBS 等负载功能提高集群的吞吐量以充分利用单机的性能？

5、是否可以添加缓存？

6、是否热点数据不均衡？

7、是否有慢 SQL ？

8、是否可以通过分库分表解决？

9、是否可以通过读写分离解决？

10、是否代码上面可以优化？

11、是否可以使用无锁编程？

12、是否可以调整 GC 策略？



分布式系统查看调用链路：定位最慢的服务，再通过对服务进行工具监控，比如arthas进行trace 命令进行方法的监控，推测最慢的函数。继续再 trace 耗时最多的子函数。

####  45.列举一些自己线上出现的故障，并详细说解决的思路和处理过程，并说明这样处理的思考和分析

####   46.有线上jvm调优经验吗？看具体要检查哪些指标？具体优化的方向和顺序是怎样的？如何保证优化的有效性？

####   47.列举一个你印象最深的一个问题，你是如何处理和解决的？

####  48.详细说说你参与最多一个项目中，遇到的一个最大的挑战？具体难点在哪里？你是如何一步步思考并处理的？你从这一挑战中得到哪些收获？

####  49.你对自己定位是什么？你对自己的职业规划是什么？

### 冒泡排序和快速排序的区别

冒泡：每次遍历选择出一个最大值，与最后一个位置交换，时间复杂度O(n^2)

快速排序：选择基准位置，比基准位置大的放左侧，比基本位置小的放右侧，（实现这个可以简化为，从左往右找一个大于基准值的，从右往左选一个小于基准值的，然后交换这两个数）将基准位置数据与边界数据交换位置，然后从上次基准位置划分开，递归排左侧，递归排右侧，直到剩一个元素。，平均时间复杂度是 `O(nlogn)`，最坏情况O(n^2)


* #### JVM的内存结构和垃圾回收机制是怎样的

  ![002hLfJYgy71J9KxlH53b](https://images2015.cnblogs.com/blog/331425/201606/331425-20160623115846235-947282498.png)

  运行时数据区：

  Java栈、本地方法栈、堆、程序计数器、方法区

  堆：年轻代、幸存区、老年代

  非堆：方法区（class类信息，静态变量、字符串常量池）

  

  线程私有：本地方法栈、程序计数器、Java栈

  程序计数器：Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储

* #### volitale是怎么保证线程可见性的

  1.可见性

  缓存一致性协议MESI

  Volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。

  2.内存屏障禁止指令重排

  sfence

  lfence

  mfence

* #### CAS的原理

  调用UnSafe的compareAndSet 方法，拿到的值与期望值一样才去设置更新，如果不一样则不更新。不能被打断。

* #### spring mvc从请求进来到响应出去的过程是怎样的

  ![这里写图片描述](https://img-blog.csdn.net/20170301213745588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdWhnYWdudQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* #### 如何保证调用服务的速率是均匀的

  漏桶算法和令牌桶算法

  #### 怎么保证服务的稳定性，当一部分服务有问题时，怎么保证服务能正常运行

  https://lework.github.io/2019/12/03/system-stability/

  常见的一些稳定性策略

  ### 1. 限流

  第一点是防止系统高负荷运行，第二点是有效利用服务器资源。 常见限流的算法包括漏桶算法和令牌桶算法。

  ### 2. 降级

  第一个是保障服务器基本可用，第二个是保障服务的核心服务可用。 以社区案例为例，即便是 My SQL 挂掉，也要能够保证社区为用户提供基本的可读服务。 一般降级的每个策略都是针对一个场景，预想特定场景下需要要解决什么问题；然后再梳理在这个场景下需要保留哪些核心基本服务；最后才选定技术方案，系统化的进行实现

  ### 3. 隔离

  隔离目的非常简单，要限制住不稳定因素导致的风险，停止传播。 如秒杀场景一个高并发的场景，可能带来的问题也比较多，在高并发场景下秒杀的时候，需要和一些正常的业务区分开来。 慢 SQL 隔离，一个资源隔离。一条慢 SQL 会导致整个服务不稳定。每请求一次线程，慢 SQL 会一直耗着当前线程，所以资源占用非常大。

  ### 4. 超时

  合理的设置业务的超时时间，可有效避免因第三方原因导致的接口等待时间过久。 设置超时时间的大体思路：第一步，识别业务需要的服务响应时间。比如，需要 100 毫秒去响应数据，之后统计业务里面可能需要调多少服务。第二步，统计服务日常的响应时间。第三步，分清主次，即分出哪些是核心服务。因为核心服务一旦失败，整个链路便不可用，所以可以对核心服务的时间设置的宽松一些。 设置完超时之后需要验证。

  ### 5. 集群

  集群的目的是为了解决单点的问题。集群的形式主要有主备，即同时只有一台机器提供整个服务，可以有一台或者多台提供备份，备份不仅要包含代码层面，整个服务运行所依赖的资源都要有备份。另外一个形式是主从。主是提供一个完整的服务，从是提供部分的服务。还有一种是多主，多主指的是每一台机器的决策是对等的，都会对外提供一些服务。

  #### 创建一个线程池有哪些因素需要考虑设置

  https://blog.csdn.net/weixin_38405253/article/details/106368698

  

* #### 为何选择使用mongodb，mongodb和mysql的区别

  https://www.jianshu.com/p/56524b50b376

* #### 

* #### 如果让你来设计一个对上层屏蔽，无感知区分读和写，但你的框架要实现读写分离的ORM框架你如何来实现

  


1.jvm内存划分？
2.常用GC算法有哪些？
3.Synchronize和ReentLock? 
4.ConcurrentHashMap实现原理？ 
5.MySQL隔离级别？
6.MySQL如何做到可重复读？ 
7.BinLog是Server层还是存储引擎层？ 
8.Redo&Undo是哪一层？ 
8.Redis 持久化机制？
9.缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题？
10、对复杂问题要有清晰的思路，考虑全面一些，比如边界或异常情况都要考虑在内；
11、通过对过去项目和系统架构如何理解？遇到问题如何解决？来考察人选的表达能力
parseInt 没写出来，又给出了个leetcode中等难度的算法题 还是没写上。

一面算法题：
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。